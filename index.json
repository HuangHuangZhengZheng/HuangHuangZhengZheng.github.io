[{"categories":["UCB-CS61B"],"content":"math problems $$ N! ∈ \\Omega (N^{N}) ? $$ √ $$ log(N!) ∈ \\Omega (NlogN) ? $$ √ $$ NlogN∈ \\Omega (log(N!)) ? $$ √ 所以可以推出： $$ NlogN ∈ \\Theta (logN!) $$ $$ log(N!) ∈ \\Theta (NlogN) $$ ","date":"2024-07-11","objectID":"/61b-35/:1:0","tags":null,"title":"61B-35","uri":"/61b-35/"},{"categories":["UCB-CS61B"],"content":"TUCS用时 上下界？ the ultimate comparison sort run time $$ \\Omega(NlogN) $$ $$ O(NlogN) $$ 下面开始证明： 考虑下界，对n个物体进行排序，有N！种可能，用两两比大小，考虑决策树的高度$$ H = \\log_2 N! $$ 因此下界为 $$ \\Omega (log(N!)) $$ 或者 $$ \\Omega (NlogN) $$ 上界通过TUCS的性质可以通过具体示例反证得到，比如用merge sort ","date":"2024-07-11","objectID":"/61b-35/:2:0","tags":null,"title":"61B-35","uri":"/61b-35/"},{"categories":["UCB-CS61B"],"content":"More quick sort, Stability, Shuffling ","date":"2024-07-11","objectID":"/61b-34/:0:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"quick sort VS merge sort QuicksortL3S = left + 3-scan + shuffle Quicksort_LTHS: Tony Hoare partition scheme: L ptr 仅仅指向小的 G ptr 仅仅指向大的 ptr walk towards to each other, stopping on a hated item 两个都停下来的话， 交换一下， 然后移动其中一个 when ptrs cross, done. 和G交换pivot ","date":"2024-07-11","objectID":"/61b-34/:1:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"Not random smarter pivot selection: median Quicksort_PickTH 考虑了如何计算数组地址的复杂度， 以及如何选择pivot的复杂度。 worst case: $$ \\Theta(NlogN) $$ 但实际上并没有那么好，因为计算中位数的复杂度是$$\\Theta(N)$$。耗费了更多时间。 ","date":"2024-07-11","objectID":"/61b-34/:2:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"quick select–using partitioning worst case: a sorted array $$ \\Theta(N^2) $$ on average: $$ N + N/2 + N/4 +… + 1 = \\Theta(N) $$ ","date":"2024-07-11","objectID":"/61b-34/:3:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"stability for stable sort, we need to keep the relative order of equal elements Is insertion sort stable? yes, it is stable. Is quick sort stable? depends on the partitioning scheme. ","date":"2024-07-11","objectID":"/61b-34/:4:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"adaptive array.sort() is adaptive 查看java官方文档 ","date":"2024-07-11","objectID":"/61b-34/:5:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"shuffling random number and then sort ","date":"2024-07-11","objectID":"/61b-34/:6:0","tags":null,"title":"61B-34","uri":"/61b-34/"},{"categories":["UCB-CS61B"],"content":"信息无损性 模糊性 ","date":"2024-07-11","objectID":"/61b-38/:0:0","tags":null,"title":"61B-38: Compression","uri":"/61b-38/"},{"categories":["UCB-CS61B"],"content":"prefix-free codes ","date":"2024-07-11","objectID":"/61b-38/:1:0","tags":null,"title":"61B-38: Compression","uri":"/61b-38/"},{"categories":["UCB-CS61B"],"content":"Huffman codes ","date":"2024-07-11","objectID":"/61b-38/:1:1","tags":null,"title":"61B-38: Compression","uri":"/61b-38/"},{"categories":["UCB-CS61B"],"content":"shannon-fano codes using tries to convert compressed data into a original data longest prefix matching ","date":"2024-07-11","objectID":"/61b-38/:1:2","tags":null,"title":"61B-38: Compression","uri":"/61b-38/"},{"categories":["UCB-CS61B"],"content":"self-extracting bits ","date":"2024-07-11","objectID":"/61b-38/:2:0","tags":null,"title":"61B-38: Compression","uri":"/61b-38/"},{"categories":["UCB-CS61B"],"content":"Overview ","date":"2024-07-11","objectID":"/61b-37/:1:0","tags":null,"title":"61B-37:overview, Tries","uri":"/61b-37/"},{"categories":["UCB-CS61B"],"content":"Tries——前缀树/字典树 usages: prefix matching approximate matching keysWithPrefix(String prefix) // returns all keys in the trie that start with the given prefix longestPrefixOf(String query) // returns the longest key in the trie that is a prefix of the query ","date":"2024-07-11","objectID":"/61b-37/:2:0","tags":null,"title":"61B-37:overview, Tries","uri":"/61b-37/"},{"categories":["UCB-CS61B"],"content":"implementation private class Node{ boolean exists; Map\u003cCharacter, Node\u003e links; public Node(){ links = new TreeMap\u003c\u003e(); exists = false; } } ","date":"2024-07-11","objectID":"/61b-37/:3:0","tags":null,"title":"61B-37:overview, Tries","uri":"/61b-37/"},{"categories":["UCB-CS61B"],"content":"T9 keyboard ","date":"2024-07-11","objectID":"/61b-37/:4:0","tags":null,"title":"61B-37:overview, Tries","uri":"/61b-37/"},{"categories":["UCB-CS61B"],"content":"Ternary search Tries public class TSTSet\u003cValue\u003e{ private Node\u003cValue\u003e root; private static class Node\u003cValue\u003e{ private char c; private Node\u003cValue\u003e lo, mid, hi; } } 但是这种实现方式表现不佳 ","date":"2024-07-11","objectID":"/61b-37/:5:0","tags":null,"title":"61B-37:overview, Tries","uri":"/61b-37/"},{"categories":["UCB-CS61B"],"content":"radix sort 不用comparisons的排序算法，时间复杂度O(dn)，d为最大数的位数，n为待排序数的个数。 空间换时间 bucket sort counting sort: 找出待排序数的最大值max，确定计数数组的长度为max+1。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k) LSD radix sort: least significant digit radix sort 找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 LSD sort vs merge sort: similar strings:LSD sort is better dissimilar strings:merge sort is better MSD radix sort: most significant digit radix sort 找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k) ","date":"2024-07-10","objectID":"/61b-36/:0:0","tags":null,"title":"61B-36","uri":"/61b-36/"},{"categories":["TOOLS"],"content":"文件状态 未跟踪-未修改-已修改-暂存 git add \u003cname\u003e - *-\u003e暂存 git commit -m \"message\" - 暂存-\u003e未修改 git rm \u003cname\u003e - 未修改-\u003e未跟踪 ","date":"2024-06-29","objectID":"/git/:1:0","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"查看状态 git status 更加细致几行几列 git diff 查看历史日志 git log --pretty=oneline git log --graph --oneline --decorate ","date":"2024-06-29","objectID":"/git/:1:1","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"基本操作 ","date":"2024-06-29","objectID":"/git/:2:0","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"基础配置 git config --global user.name \"your name\" git config --global user.email \"your email\" ","date":"2024-06-29","objectID":"/git/:2:1","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"创建版本库 mkdir myproject cd myproject git init ","date":"2024-06-29","objectID":"/git/:2:2","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"克隆版本库 git clone https://github.com/username/repository.git ","date":"2024-06-29","objectID":"/git/:2:3","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"跟踪文件or文件夹 git add \u003cfilename\u003e git rm \u003cfilename\u003e git rm --cache \u003cfilename\u003e ","date":"2024-06-29","objectID":"/git/:2:4","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"设置缓存状态 git add git reset HEAD \u003cfilename\u003e ","date":"2024-06-29","objectID":"/git/:2:5","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"提交修改 git commit -m \"commit message str\" 撤销非首次修改 git reset head~ --soft ","date":"2024-06-29","objectID":"/git/:2:6","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"和github联系 git remote add origin https://github.com/username/repository.git git remote git remote rename origin old_name 推到远程仓库 git push origin master ssh连接？ ","date":"2024-06-29","objectID":"/git/:2:7","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"分支管理 创建分支 git branch --list git branch hhzz git checkout hhzz git checkout -b hhzz 合并分支 git merge hhzz 删除分支 git branch -d hhzz ","date":"2024-06-29","objectID":"/git/:2:8","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"贮藏功能 stash 待施工 ","date":"2024-06-29","objectID":"/git/:2:9","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"重置、换基功能 待施工 ","date":"2024-06-29","objectID":"/git/:2:10","tags":null,"title":"Git","uri":"/git/"},{"categories":["TOOLS"],"content":"Regular Expressions ","date":"2024-06-29","objectID":"/reg/:0:0","tags":null,"title":"正则表达式笔记","uri":"/reg/"},{"categories":["TOOLS"],"content":"注意版本和文档！ ","date":"2024-06-29","objectID":"/reg/:1:0","tags":null,"title":"正则表达式笔记","uri":"/reg/"},{"categories":["TOOLS"],"content":"常用工具 https://regex101.com/ https://regexr.com/ python re模块 字符 . 匹配任意一个字符 [] 匹配括号中的任意一个字符,如 [a-zA-Z1-3] 匹配大写字母或小写字母或数字1-3, [^] 匹配除了括号中的字符 预定字符类 \\d 匹配数字 \\D 匹配非数字 \\w 匹配字母、数字或下划线 \\W 匹配非字母、数字或下划线 \\s 匹配空白字符或者tab \\S 匹配非空白字符 边界匹配 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \\b 匹配单词的边界, 如 \\bthe\\b 匹配the \\B 匹配非单词边界 数量词 * 匹配前面的字符0次或多次 + 匹配前面的字符1次或多次 ? 匹配前面的字符0次或1次 {n} 匹配前面的字符n次 {n,} 匹配前面的字符至少n次 {n,m} 匹配前面的字符至少n次, 至多m次 非贪婪匹配 量词默认是贪婪匹配, 即尽可能多的匹配字符, 如 a.*b 会匹配到最长的以a开头的b 后面的量词加上? 则为非贪婪匹配, 即尽可能少的匹配字符, 如 a.*?b 会匹配到最短的以a开头的b 分组与捕获 () 用来创建分组, 捕获括号中的字符, 并在匹配时返回匹配到的内容 [] 用来创建字符类, 如 [Pp] 匹配P或p | 用来创建或关系, 如 a(bc|de) 匹配a后面是bc或de \\n 引用分组, 如 \\1 引用第一个分组 $n 引用第n个分组 ?: 非捕获分组, 如 (?:abc) 匹配abc, 不捕获匹配到的内容 前瞻和后顾 正向前瞻 (?=abc) 匹配abc前面的字符 反向前瞻 (?!abc) 匹配abc前面的字符 正向后顾 (?\u003c=abc) 匹配abc后面的字符 反向后顾 (?\u003c!abc) 匹配abc后面的字符 ","date":"2024-06-29","objectID":"/reg/:2:0","tags":null,"title":"正则表达式笔记","uri":"/reg/"},{"categories":["C++"],"content":"learning pointer(advanced version) 为了防止搞混而写 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:0","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"下标为0?首地址? void test0(){ int arr[] = {1, 2, 3}; cout \u003c\u003c \u0026arr[0] \u003c\u003c endl; cout \u003c\u003c \u0026arr \u003c\u003c endl; cout \u003c\u003c arr \u003c\u003c endl; } arr \u0026arr \u0026arr[0] 存储的都是相同的地址 arr 常量指针不能被改变 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:1","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"指向数组元素的指针(不一定是首元素)以用[]来访问数组元素 void test2() { int a[3] = {1,2,3}; int *p = a; p++; cout \u003c\u003c p[0] \u003c\u003c endl; // 2 } ","date":"2024-05-05","objectID":"/basic_cpp1/:0:2","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"数组类型的指针 void test2(){ int arr[] = {1, 2, 3}; int (*p)[] = \u0026arr; // 定义一个指向数组的指针 cout \u003c\u003c (*p)[0] \u003c\u003c endl; // 输出数组首地址 cout \u003c\u003c p[0] \u003c\u003c endl; // 输出数组首地址 cout \u003c\u003c p[0][0] \u003c\u003c endl; // 输出数组首元素 } int *p[] = \u0026arr vs int (*p)[] = \u0026arr???? [ ]优先级高于* int (*p)[] = \u0026arr; *p --\u003e 一个指针 （*p）[] --\u003e 指向数组的指针 int (*p)[] --\u003e 指向的数组的元素是int类型 p = \u0026arr 定义了一个指向数组的指针，(*p) = arr 解引用指针得到数组首地址，(*p)[0] = arr[0] 访问数组首元素 p[0] = arr 访问数组首地址，p[0][0] = arr[0] 访问数组首元素 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:3","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"那么int *(*p)[] = { };水到渠成了 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:4","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"内存映像图 内存映像图 1 2 … 内存地址从上往下递增 和CSAPP里面的栈画法有点不一样 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:5","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"delete 申请一个连续的内存块，然后将其视为二维数组： int** arr = new int*[rows]; for (int i = 0; i \u003c rows; ++i) { arr[i] = new int[cols]; } 释放时，你需要先释放每一行的内存，然后释放行指针数组： for (int i = 0; i \u003c rows; ++i) { delete[] arr[i]; } delete[] arr; 申请一个足够大的连续内存块，然后将其视为二维数组： int* arr = new int[rows * cols]; 在这种情况下，你只需要释放一次： delete[] arr; 注意，这种方式下，arr实际上是一个一维数组，但是你可以像访问二维数组一样使用它（例如，arr[i][j]实际上是arr[i * cols + j]）。 确保在释放内存后将指针设置为nullptr，以避免悬垂指针问题： delete[] arr; arr = nullptr; // 或者使用智能指针自动管理内存 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:6","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"char? int main() { char **p, *city[] = {\"aaa\",\"bbb\"}; for (p = city; p \u003c city + 2; ++p) { cout \u003c\u003c *p \u003c\u003c endl; } return 0; } 结果为： aaa bbb ","date":"2024-05-05","objectID":"/basic_cpp1/:0:7","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["csapp"],"content":"实验一：栈溢出攻击实验 ","date":"2024-04-22","objectID":"/csapp_attacklab/:1:0","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"栈的基本结构 ","date":"2024-04-22","objectID":"/csapp_attacklab/:1:1","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"实验二：ROP攻击实验 ","date":"2024-04-22","objectID":"/csapp_attacklab/:2:0","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"csapp_bomblab 都是汇编语言，没有什么好说的 注意GDB调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:0:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"核心概念之一：寻址 如何寻址？ $Imm(r_1,r_2,factor)$ 注意值还是地址？ (%rdx)取memory时，$M[R_i]$ 中M一直在最外层 ","date":"2024-04-22","objectID":"/csapp_bomblab/:1:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"核心概念之二：GDB调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:2:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"常用命令 run 运行程序（注意结合数据流pipeline） b +$Addr$ 设置断点 delete 删除断点 next 单步执行 step stepi``finish进入函数 p $eax 打印变量 x /$nxb $Addr$ 打印内存 layout asm 切换到汇编模式有好看的窗口 info registers 打印寄存器 info frame 打印栈帧 info args 打印函数参数 info locals 打印局部变量 info breakpoints 打印断点信息 continue 继续运行 quit stop退出调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:2:1","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"一些些技巧 mov一些奇奇怪怪的地址时，很可能是线索，可以用x /$nxb $Addr$查看内存 jne之类的能不能直接取等擦边通过 常见的基础语句（条件/循环）有一些固定的范式，可以用x /6i $PC等查看指令 ","date":"2024-04-22","objectID":"/csapp_bomblab/:3:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["CSAPP"],"content":"int bit-level operations ","date":"2024-04-21","objectID":"/csapp_datalab/:1:0","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"德摩根律（位运算和集合论） 与：\u0026 非：~ 两者组合已经可以表示四个基本运算：与、非、或、异或。 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:1","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"移动位运算 注意是否为无符号数，有符号数的移位运算规则与无符号数不同。 有符号数的移位运算规则： 左移：符号位不变，右边补0。 右移：符号位不变，左边补符号位。 无符号数的移位运算规则： 左移：左边补0。 右移：右边补0。 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:2","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"与运算（\u0026）取特定的位数，用于位层面条件判断 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:3","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"减法的实现 A + ~A = -1 –\u003e A + (~A+1) = 0 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:4","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"减法的描述范围问题 做差取符号位 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:5","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"掩码操作 int conditional(int x, int y, int z) { int exp1 = ~(!!x) + 1; int exp2 = ~(!x) + 1; return (exp1\u0026y) + (exp2\u0026z); } ","date":"2024-04-21","objectID":"/csapp_datalab/:1:6","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"位层面分类讨论 /* howManyBits - return the minimum number of bits required to represent x in * two's complement(补码系统) * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 负数的话 取反 同理 * howManyBits(0) = 1 * howManyBits(-1) = 1 特殊点? * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { // 取为正数操作 int flag = x \u003e\u003e 31; x = (~flag \u0026 x) + (flag \u0026 (~x)); // 掩码分类思想 // 0000 0100 0000 0000 0000 0000 0000 0000 // Flag_i = !!(x \u003e\u003e i) int bit16 = !!(x \u003e\u003e 16) \u003c\u003c 4; // log2 N x \u003e\u003e= bit16; // \u003e\u003e= 右移赋值运算符 int bit8 = !!(x \u003e\u003e 8) \u003c\u003c 3; x \u003e\u003e= bit8; int bit4 = !!(x \u003e\u003e 4) \u003c\u003c 2; x \u003e\u003e= bit4; int bit2 = !!(x \u003e\u003e 2) \u003c\u003c 1; x \u003e\u003e= bit2; int bit1 = !!(x \u003e\u003e 1) \u003c\u003c 0; x \u003e\u003e= bit1; int bit0 = x; // x = 1 return (bit0+bit1+bit2+bit4+bit8+bit16) + 1; } ","date":"2024-04-21","objectID":"/csapp_datalab/:1:7","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"float bit-level operations $$ float = (-1)^s * M * 2^E $$ ","date":"2024-04-21","objectID":"/csapp_datalab/:2:0","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"float to binary sign bit: $s$ exponent bits: $E$ —\u003e $E = e - 127$ mantissa bits: $M$—\u003efrac add $1$ and $0$ to the left until $M$ has 23 bits ","date":"2024-04-21","objectID":"/csapp_datalab/:2:1","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["weekly_random_thoughts"],"content":"HHZZ会爱markdown和latex工程系的 ","date":"2024-04-20","objectID":"/first_post/:1:0","tags":["markdown","latex"],"title":"First_post","uri":"/first_post/"}]