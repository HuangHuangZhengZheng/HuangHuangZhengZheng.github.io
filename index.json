[{"categories":["C++"],"content":"learning pointer(advanced version) 为了防止搞混而写 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:0","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"下标为0?首地址? void test0(){ int arr[] = {1, 2, 3}; cout \u003c\u003c \u0026arr[0] \u003c\u003c endl; cout \u003c\u003c \u0026arr \u003c\u003c endl; cout \u003c\u003c arr \u003c\u003c endl; } arr \u0026arr \u0026arr[0] 存储的都是相同的地址 arr 常量指针不能被改变 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:1","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"指向数组元素的指针(不一定是首元素)以用[]来访问数组元素 void test2() { int a[3] = {1,2,3}; int *p = a; p++; cout \u003c\u003c p[0] \u003c\u003c endl; // 2 } ","date":"2024-05-05","objectID":"/basic_cpp1/:0:2","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"数组类型的指针 void test2(){ int arr[] = {1, 2, 3}; int (*p)[] = \u0026arr; // 定义一个指向数组的指针 cout \u003c\u003c (*p)[0] \u003c\u003c endl; // 输出数组首地址 cout \u003c\u003c p[0] \u003c\u003c endl; // 输出数组首地址 cout \u003c\u003c p[0][0] \u003c\u003c endl; // 输出数组首元素 } int *p[] = \u0026arr vs int (*p)[] = \u0026arr???? [ ]优先级高于* int (*p)[] = \u0026arr; *p --\u003e 一个指针 （*p）[] --\u003e 指向数组的指针 int (*p)[] --\u003e 指向的数组的元素是int类型 p = \u0026arr 定义了一个指向数组的指针，(*p) = arr 解引用指针得到数组首地址，(*p)[0] = arr[0] 访问数组首元素 p[0] = arr 访问数组首地址，p[0][0] = arr[0] 访问数组首元素 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:3","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"那么int *(*p)[] = { };水到渠成了 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:4","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["C++"],"content":"内存映像图 内存映像图 1 2 … 内存地址从上往下递增 和CSAPP里面的栈画法有点不一样 ","date":"2024-05-05","objectID":"/basic_cpp1/:0:5","tags":["C++"],"title":"C++ ptr","uri":"/basic_cpp1/"},{"categories":["weekly_random_thoughts"],"content":"第十一周随想 一时兴起，感觉需要梳理一下所谓人生（尤其是转专业第一次失败之后） 这个专栏在周老师@SJTU的启发下决定开始书写，每周至少一篇记录一下抽象生活 ","date":"2024-04-29","objectID":"/try/:0:0","tags":null,"title":"first_thoughts","uri":"/try/"},{"categories":["csapp"],"content":"实验一：栈溢出攻击实验 ","date":"2024-04-22","objectID":"/csapp_attacklab/:1:0","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"栈的基本结构 ","date":"2024-04-22","objectID":"/csapp_attacklab/:1:1","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"实验二：ROP攻击实验 ","date":"2024-04-22","objectID":"/csapp_attacklab/:2:0","tags":null,"title":"CSAPP_attacklab","uri":"/csapp_attacklab/"},{"categories":["csapp"],"content":"csapp_bomblab 都是汇编语言，没有什么好说的 注意GDB调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:0:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"核心概念之一：寻址 如何寻址？ $Imm(r_1,r_2,factor)$ 注意值还是地址？ (%rdx)取memory时，$M[R_i]$ 中M一直在最外层 ","date":"2024-04-22","objectID":"/csapp_bomblab/:1:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"核心概念之二：GDB调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:2:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"常用命令 run 运行程序（注意结合数据流pipeline） b +$Addr$ 设置断点 delete 删除断点 next 单步执行 step stepi``finish进入函数 p $eax 打印变量 x /$nxb $Addr$ 打印内存 layout asm 切换到汇编模式有好看的窗口 info registers 打印寄存器 info frame 打印栈帧 info args 打印函数参数 info locals 打印局部变量 info breakpoints 打印断点信息 continue 继续运行 quit stop退出调试 ","date":"2024-04-22","objectID":"/csapp_bomblab/:2:1","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["csapp"],"content":"一些些技巧 mov一些奇奇怪怪的地址时，很可能是线索，可以用x /$nxb $Addr$查看内存 jne之类的能不能直接取等擦边通过 常见的基础语句（条件/循环）有一些固定的范式，可以用x /6i $PC等查看指令 ","date":"2024-04-22","objectID":"/csapp_bomblab/:3:0","tags":null,"title":"CSAPP_bomblab","uri":"/csapp_bomblab/"},{"categories":["CSAPP"],"content":"int bit-level operations ","date":"2024-04-21","objectID":"/csapp_datalab/:1:0","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"德摩根律（位运算和集合论） 与：\u0026 非：~ 两者组合已经可以表示四个基本运算：与、非、或、异或。 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:1","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"移动位运算 注意是否为无符号数，有符号数的移位运算规则与无符号数不同。 有符号数的移位运算规则： 左移：符号位不变，右边补0。 右移：符号位不变，左边补符号位。 无符号数的移位运算规则： 左移：左边补0。 右移：右边补0。 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:2","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"与运算（\u0026）取特定的位数，用于位层面条件判断 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:3","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"减法的实现 A + ~A = -1 –\u003e A + (~A+1) = 0 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:4","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"减法的描述范围问题 做差取符号位 ","date":"2024-04-21","objectID":"/csapp_datalab/:1:5","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"掩码操作 int conditional(int x, int y, int z) { int exp1 = ~(!!x) + 1; int exp2 = ~(!x) + 1; return (exp1\u0026y) + (exp2\u0026z); } ","date":"2024-04-21","objectID":"/csapp_datalab/:1:6","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"位层面分类讨论 /* howManyBits - return the minimum number of bits required to represent x in * two's complement(补码系统) * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 负数的话 取反 同理 * howManyBits(0) = 1 * howManyBits(-1) = 1 特殊点? * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { // 取为正数操作 int flag = x \u003e\u003e 31; x = (~flag \u0026 x) + (flag \u0026 (~x)); // 掩码分类思想 // 0000 0100 0000 0000 0000 0000 0000 0000 // Flag_i = !!(x \u003e\u003e i) int bit16 = !!(x \u003e\u003e 16) \u003c\u003c 4; // log2 N x \u003e\u003e= bit16; // \u003e\u003e= 右移赋值运算符 int bit8 = !!(x \u003e\u003e 8) \u003c\u003c 3; x \u003e\u003e= bit8; int bit4 = !!(x \u003e\u003e 4) \u003c\u003c 2; x \u003e\u003e= bit4; int bit2 = !!(x \u003e\u003e 2) \u003c\u003c 1; x \u003e\u003e= bit2; int bit1 = !!(x \u003e\u003e 1) \u003c\u003c 0; x \u003e\u003e= bit1; int bit0 = x; // x = 1 return (bit0+bit1+bit2+bit4+bit8+bit16) + 1; } ","date":"2024-04-21","objectID":"/csapp_datalab/:1:7","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"float bit-level operations $$ float = (-1)^s * M * 2^E $$ ","date":"2024-04-21","objectID":"/csapp_datalab/:2:0","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["CSAPP"],"content":"float to binary sign bit: $s$ exponent bits: $E$ —\u003e $E = e - 127$ mantissa bits: $M$—\u003efrac add $1$ and $0$ to the left until $M$ has 23 bits ","date":"2024-04-21","objectID":"/csapp_datalab/:2:1","tags":null,"title":"CSAPP_datalab","uri":"/csapp_datalab/"},{"categories":["weekly_random_thoughts"],"content":"HHZZ会爱markdown和latex工程系的 ","date":"2024-04-20","objectID":"/first_post/:1:0","tags":["markdown","latex"],"title":"First_post","uri":"/first_post/"}]