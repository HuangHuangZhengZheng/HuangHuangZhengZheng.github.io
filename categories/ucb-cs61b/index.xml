<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>UCB-CS61B - Category - HHZZ`s space</title>
        <link>http://example.org/categories/ucb-cs61b/</link>
        <description>UCB-CS61B - Category - HHZZ`s space</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 11 Jul 2024 11:46:17 &#43;0800</lastBuildDate><atom:link href="http://example.org/categories/ucb-cs61b/" rel="self" type="application/rss+xml" /><item>
    <title>61B-35</title>
    <link>http://example.org/61b-35/</link>
    <pubDate>Thu, 11 Jul 2024 11:46:17 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-35/</guid>
    <description><![CDATA[math problems $$ N! ∈ \Omega (N^{N}) ? $$ √
$$ log(N!) ∈ \Omega (NlogN) ? $$ √
$$ NlogN∈ \Omega (log(N!)) ? $$ √
所以可以推出：
$$ NlogN ∈ \Theta (logN!) $$
$$ log(N!) ∈ \Theta (NlogN) $$
TUCS用时 上下界？ the ultimate comparison sort run time
$$ \Omega(NlogN) $$
$$ O(NlogN) $$
下面开始证明： 考虑下界，对n个物体进行排序，有N！种可能，用两两比大小，考虑决策树的高度$$ H = \log_2 N! $$ 因此下界为 $$ \Omega (log(N!)) $$ 或者 $$ \Omega (NlogN) $$ 上界通过TUCS的性质可以通过具体示例反证得到，比如用merge sort]]></description>
</item>
<item>
    <title>61B-34</title>
    <link>http://example.org/61b-34/</link>
    <pubDate>Thu, 11 Jul 2024 11:43:13 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-34/</guid>
    <description><![CDATA[More quick sort, Stability, Shuffling quick sort VS merge sort QuicksortL3S = left + 3-scan + shuffle
Quicksort_LTHS:
Tony Hoare partition scheme:
L ptr 仅仅指向小的 G ptr 仅仅指向大的 ptr walk towards to each other, stopping on a hated item 两个都停下来的话， 交换一下， 然后移动其中一个 when ptrs cross, done. 和G交换pivot Not random smarter pivot selection: median Quicksort_PickTH
考虑了如何计算数组地址的复杂度， 以及如何选择pivot的复杂度。
worst case: $$ \Theta(NlogN) $$
但实际上并没有那么好，因为计算中位数的复杂度是$$\Theta(N)$$。耗费了更多时间。
quick select&ndash;using partitioning worst case:
a sorted array $$ \Theta(N^2) $$]]></description>
</item>
<item>
    <title>61B-38: Compression</title>
    <link>http://example.org/61b-38/</link>
    <pubDate>Thu, 11 Jul 2024 10:13:26 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-38/</guid>
    <description><![CDATA[信息无损性 模糊性
prefix-free codes Huffman codes shannon-fano codes using tries to convert compressed data into a original data longest prefix matching
self-extracting bits ]]></description>
</item>
<item>
    <title>61B-37:overview, Tries</title>
    <link>http://example.org/61b-37/</link>
    <pubDate>Thu, 11 Jul 2024 08:46:02 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-37/</guid>
    <description><![CDATA[Overview Tries——前缀树/字典树 usages:
prefix matching approximate matching 1 2 keysWithPrefix(String prefix) // returns all keys in the trie that start with the given prefix longestPrefixOf(String query) // returns the longest key in the trie that is a prefix of the query implementation 1 2 3 4 5 6 7 8 private class Node{ boolean exists; Map&lt;Character, Node&gt; links; public Node(){ links = new TreeMap&lt;&gt;(); exists = false; } } T9 keyboard Ternary search Tries 1 2 3 4 5 6 7 public class TSTSet&lt;Value&gt;{ private Node&lt;Value&gt; root; private static class Node&lt;Value&gt;{ private char c; private Node&lt;Value&gt; lo, mid, hi; } } 但是这种实现方式表现不佳 ]]></description>
</item>
<item>
    <title>61B-36</title>
    <link>http://example.org/61b-36/</link>
    <pubDate>Wed, 10 Jul 2024 23:30:58 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-36/</guid>
    <description><![CDATA[radix sort 不用comparisons的排序算法，时间复杂度O(dn)，d为最大数的位数，n为待排序数的个数。
空间换时间
bucket sort
counting sort:
找出待排序数的最大值max，确定计数数组的长度为max+1。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k)
LSD radix sort: least significant digit radix sort
找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 LSD sort vs merge sort:
similar strings:LSD sort is better
dissimilar strings:merge sort is better
MSD radix sort: most significant digit radix sort
找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k)]]></description>
</item>
</channel>
</rss>
