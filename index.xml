<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>HHZZ`s space</title>
        <link>http://example.org/</link>
        <description>This is my cool site</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 11 Jul 2024 11:46:17 &#43;0800</lastBuildDate>
            <atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>61B-35</title>
    <link>http://example.org/61b-35/</link>
    <pubDate>Thu, 11 Jul 2024 11:46:17 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-35/</guid>
    <description><![CDATA[math problems $$ N! ∈ \Omega (N^{N}) ? $$ √
$$ log(N!) ∈ \Omega (NlogN) ? $$ √
$$ NlogN∈ \Omega (log(N!)) ? $$ √
所以可以推出：
$$ NlogN ∈ \Theta (logN!) $$
$$ log(N!) ∈ \Theta (NlogN) $$
TUCS用时 上下界？ the ultimate comparison sort run time
$$ \Omega(NlogN) $$
$$ O(NlogN) $$
下面开始证明： 考虑下界，对n个物体进行排序，有N！种可能，用两两比大小，考虑决策树的高度$$ H = \log_2 N! $$ 因此下界为 $$ \Omega (log(N!)) $$ 或者 $$ \Omega (NlogN) $$ 上界通过TUCS的性质可以通过具体示例反证得到，比如用merge sort]]></description>
</item>
<item>
    <title>61B-34</title>
    <link>http://example.org/61b-34/</link>
    <pubDate>Thu, 11 Jul 2024 11:43:13 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-34/</guid>
    <description><![CDATA[More quick sort, Stability, Shuffling quick sort VS merge sort QuicksortL3S = left + 3-scan + shuffle
Quicksort_LTHS:
Tony Hoare partition scheme:
L ptr 仅仅指向小的 G ptr 仅仅指向大的 ptr walk towards to each other, stopping on a hated item 两个都停下来的话， 交换一下， 然后移动其中一个 when ptrs cross, done. 和G交换pivot Not random smarter pivot selection: median Quicksort_PickTH
考虑了如何计算数组地址的复杂度， 以及如何选择pivot的复杂度。
worst case: $$ \Theta(NlogN) $$
但实际上并没有那么好，因为计算中位数的复杂度是$$\Theta(N)$$。耗费了更多时间。
quick select&ndash;using partitioning worst case:
a sorted array $$ \Theta(N^2) $$]]></description>
</item>
<item>
    <title>61B-38: Compression</title>
    <link>http://example.org/61b-38/</link>
    <pubDate>Thu, 11 Jul 2024 10:13:26 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-38/</guid>
    <description><![CDATA[信息无损性 模糊性
prefix-free codes Huffman codes shannon-fano codes using tries to convert compressed data into a original data longest prefix matching
self-extracting bits ]]></description>
</item>
<item>
    <title>61B-37:overview, Tries</title>
    <link>http://example.org/61b-37/</link>
    <pubDate>Thu, 11 Jul 2024 08:46:02 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-37/</guid>
    <description><![CDATA[Overview Tries——前缀树/字典树 usages:
prefix matching approximate matching 1 2 keysWithPrefix(String prefix) // returns all keys in the trie that start with the given prefix longestPrefixOf(String query) // returns the longest key in the trie that is a prefix of the query implementation 1 2 3 4 5 6 7 8 private class Node{ boolean exists; Map&lt;Character, Node&gt; links; public Node(){ links = new TreeMap&lt;&gt;(); exists = false; } } T9 keyboard Ternary search Tries 1 2 3 4 5 6 7 public class TSTSet&lt;Value&gt;{ private Node&lt;Value&gt; root; private static class Node&lt;Value&gt;{ private char c; private Node&lt;Value&gt; lo, mid, hi; } } 但是这种实现方式表现不佳 ]]></description>
</item>
<item>
    <title>61B-36</title>
    <link>http://example.org/61b-36/</link>
    <pubDate>Wed, 10 Jul 2024 23:30:58 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/61b-36/</guid>
    <description><![CDATA[radix sort 不用comparisons的排序算法，时间复杂度O(dn)，d为最大数的位数，n为待排序数的个数。
空间换时间
bucket sort
counting sort:
找出待排序数的最大值max，确定计数数组的长度为max+1。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k)
LSD radix sort: least significant digit radix sort
找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 LSD sort vs merge sort:
similar strings:LSD sort is better
dissimilar strings:merge sort is better
MSD radix sort: most significant digit radix sort
找出待排序数的最大值max，确定计数数组的长度为10。 遍历待排序数，将每个数的个位数值作为索引，将该索引对应的计数数组元素加1。 遍历计数数组，将每个元素的值作为索引，将该索引对应的元素值输出到结果数组中。 runtime: O(n+k)]]></description>
</item>
<item>
    <title>Git</title>
    <link>http://example.org/git/</link>
    <pubDate>Sat, 29 Jun 2024 15:06:38 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/git/</guid>
    <description><![CDATA[文件状态 未跟踪-未修改-已修改-暂存 git add &lt;name&gt; - *-&gt;暂存 git commit -m &quot;message&quot; - 暂存-&gt;未修改 git rm &lt;name&gt; - 未修改-&gt;未跟踪
查看状态 1 git status 更加细致几行几列
1 git diff 查看历史日志
1 2 git log --pretty=oneline git log --graph --oneline --decorate 基本操作 基础配置 1 2 git config --global user.name &#34;your name&#34; git config --global user.email &#34;your email&#34; 创建版本库 1 2 3 mkdir myproject cd myproject git init 克隆版本库 1 git clone https://github.com/username/repository.git 跟踪文件or文件夹 1 git add &lt;filename&gt; 1 2 git rm &lt;filename&gt; git rm --cache &lt;filename&gt; 设置缓存状态 1 git add 1 git reset HEAD &lt;filename&gt; 提交修改 1 git commit -m &#34;commit message str&#34; 撤销非首次修改]]></description>
</item>
<item>
    <title>正则表达式笔记</title>
    <link>http://example.org/reg/</link>
    <pubDate>Sat, 29 Jun 2024 13:37:39 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/reg/</guid>
    <description><![CDATA[Regular Expressions 注意版本和文档！ 常用工具 https://regex101.com/ https://regexr.com/ python re模块
字符 . 匹配任意一个字符 [] 匹配括号中的任意一个字符,如 [a-zA-Z1-3] 匹配大写字母或小写字母或数字1-3, [^] 匹配除了括号中的字符
预定字符类 \d 匹配数字 \D 匹配非数字 \w 匹配字母、数字或下划线 \W 匹配非字母、数字或下划线 \s 匹配空白字符或者tab \S 匹配非空白字符
边界匹配 ^ 匹配字符串的开头 $ 匹配字符串的结尾 \b 匹配单词的边界, 如 \bthe\b 匹配the \B 匹配非单词边界
数量词 * 匹配前面的字符0次或多次 + 匹配前面的字符1次或多次 ? 匹配前面的字符0次或1次 {n} 匹配前面的字符n次 {n,} 匹配前面的字符至少n次 {n,m} 匹配前面的字符至少n次, 至多m次
非贪婪匹配 量词默认是贪婪匹配, 即尽可能多的匹配字符, 如 a.*b 会匹配到最长的以a开头的b 后面的量词加上? 则为非贪婪匹配, 即尽可能少的匹配字符, 如 a.*?b 会匹配到最短的以a开头的b
分组与捕获 () 用来创建分组, 捕获括号中的字符, 并在匹配时返回匹配到的内容 [] 用来创建字符类, 如 [Pp] 匹配P或p | 用来创建或关系, 如 a(bc|de) 匹配a后面是bc或de \n 引用分组, 如 \1 引用第一个分组 $n 引用第n个分组 ?]]></description>
</item>
<item>
    <title>C&#43;&#43; ptr</title>
    <link>http://example.org/basic_cpp1/</link>
    <pubDate>Sun, 05 May 2024 22:24:42 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/basic_cpp1/</guid>
    <description><![CDATA[learning pointer(advanced version) 为了防止搞混而写
下标为0?首地址? 1 2 3 4 5 6 void test0(){ int arr[] = {1, 2, 3}; cout &lt;&lt; &amp;arr[0] &lt;&lt; endl; cout &lt;&lt; &amp;arr &lt;&lt; endl; cout &lt;&lt; arr &lt;&lt; endl; } arr &amp;arr &amp;arr[0] 存储的都是相同的地址 arr 常量指针不能被改变 指向数组元素的指针(不一定是首元素)以用[]来访问数组元素 1 2 3 4 5 6 void test2() { int a[3] = {1,2,3}; int *p = a; p++; cout &lt;&lt; p[0] &lt;&lt; endl; // 2 } 数组类型的指针 1 2 3 4 5 6 7 void test2(){ int arr[] = {1, 2, 3}; int (*p)[] = &amp;arr; // 定义一个指向数组的指针 cout &lt;&lt; (*p)[0] &lt;&lt; endl; // 输出数组首地址 cout &lt;&lt; p[0] &lt;&lt; endl; // 输出数组首地址 cout &lt;&lt; p[0][0] &lt;&lt; endl; // 输出数组首元素 } int *p[] = &amp;arr vs int (*p)[] = &amp;arr?]]></description>
</item>
<item>
    <title>first_thoughts</title>
    <link>http://example.org/try/</link>
    <pubDate>Mon, 29 Apr 2024 15:52:37 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/try/</guid>
    <description><![CDATA[]]></description>
</item>
<item>
    <title>CSAPP_attacklab</title>
    <link>http://example.org/csapp_attacklab/</link>
    <pubDate>Mon, 22 Apr 2024 08:40:36 &#43;0800</pubDate>
    <author>HHZZ</author>
    <guid>http://example.org/csapp_attacklab/</guid>
    <description><![CDATA[实验一：栈溢出攻击实验 栈的基本结构 实验二：ROP攻击实验 ]]></description>
</item>
</channel>
</rss>
